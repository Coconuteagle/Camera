<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Gesture Controlled Saturn</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; }
        video { display: none; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #ffd700;
            font-family: sans-serif;
            pointer-events: none;
            z-index: 10;
            text-shadow: 0 0 5px black;
            font-size: 1.2rem;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <div id="info">âœŠ ì£¼ë¨¹: í† ì„± ì†Œí™˜ | ğŸ– ì†ë°”ë‹¥: í©ì–´ì§€ê¸° & ë¬¼ê²°ì¹˜ê¸°</div>
    <video id="input_video"></video>
    
    <script>
        let isSaturnMode = false; // ì£¼ë¨¹ ì¥ë©´ true, í´ë©´ false

        // 1. Three.js ì„¤ì •
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.005);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        camera.position.z = 60;

        // 2. ì…ì ìƒì„± (ê¸ˆìƒ‰, ì„¸ë°€í•˜ê²Œ)
        const particleCount = 12000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const originalPositions = new Float32Array(particleCount * 3);
        const saturnPositions = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;

            // ê¸°ë³¸ ìœ„ì¹˜ (ë„“ê²Œ ë¶„í¬)
            const spread = 120;
            positions[i3] = (Math.random() - 0.5) * spread;
            positions[i3 + 1] = (Math.random() - 0.5) * spread;
            positions[i3 + 2] = (Math.random() - 0.5) * spread;
            
            originalPositions[i3] = positions[i3];
            originalPositions[i3 + 1] = positions[i3 + 1];
            originalPositions[i3 + 2] = positions[i3 + 2];

            // í† ì„± ëª©í‘œ ìœ„ì¹˜ ê³„ì‚°
            if (i < particleCount * 0.25) { // ì¤‘ì•™ êµ¬ì²´
                const radius = Math.random() * 8;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                saturnPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                saturnPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                saturnPositions[i3 + 2] = radius * Math.cos(phi);
            } else { // ê³ ë¦¬
                const innerRadius = 12;
                const outerRadius = 25;
                const ringRadius = innerRadius + Math.random() * (outerRadius - innerRadius);
                const angle = (i / particleCount) * Math.PI * 2 * 10;
                
                saturnPositions[i3] = Math.cos(angle) * ringRadius;
                saturnPositions[i3 + 1] = (Math.random() -0.5) * 1.5; 
                saturnPositions[i3 + 2] = Math.sin(angle) * ringRadius;
            }
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const material = new THREE.PointsMaterial({
            color: 0xffcc00, 
            size: 0.3,      
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // ì† ì¢Œí‘œ
        let handPos = { x: 9999, y: 9999 };

        // 3. MediaPipe Hands
        const videoElement = document.getElementById('input_video');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // ì£¼ë¨¹ ì¸ì‹ í•¨ìˆ˜
        function isFist(landmarks) {
            // ì ‘íŒ ì†ê°€ë½ ê°œìˆ˜ ì„¸ê¸° (ì—„ì§€ ì œì™¸ ê²€ì§€~ìƒˆë¼)
            let foldedCount = 0;
            // 8:ê²€ì§€ë, 6:ê²€ì§€ê´€ì ˆ ... 
            if (landmarks[8].y > landmarks[6].y) foldedCount++;  // í™”ë©´ìƒ ì•„ë˜ìª½ì´ yê°’ì´ í¼ (ë³´í†µ ì†ê°€ë½ ë‚´ë¦¬ë©´ yì¦ê°€)
            if (landmarks[12].y > landmarks[10].y) foldedCount++;
            if (landmarks[16].y > landmarks[14].y) foldedCount++;
            if (landmarks[20].y > landmarks[18].y) foldedCount++;
            
            // ì†ì´ ë’¤ì§‘í˜€ìˆì„ ìˆ˜ë„ ìˆìœ¼ë‹ˆ, ì†ëª©(0)ê³¼ ì†ê°€ë½ ë ê±°ë¦¬ë¡œ íŒë‹¨í•˜ëŠ” ê²Œ ë” ì •í™•í•¨
            const wrist = landmarks[0];
            const tips = [8, 12, 16, 20];
            const pips = [6, 10, 14, 18]; // ì¤‘ê°„ ê´€ì ˆ
            
            let closeCount = 0;
            for(let i=0; i<4; i++) {
                // ì†ëª©-ì†ë ê±°ë¦¬ vs ì†ëª©-ì¤‘ê°„ê´€ì ˆ ê±°ë¦¬ ë¹„êµ
                const dTip = dist(wrist, landmarks[tips[i]]);
                const dPip = dist(wrist, landmarks[pips[i]]);
                // ì†ëì´ ê´€ì ˆë³´ë‹¤ ì†ëª©ì— ê°€ê¹Œìš°ë©´ ì ‘íŒ ê²ƒ
                if (dTip < dPip * 1.2) closeCount++; 
            }
            
            return closeCount >= 3; // 3ê°œ ì´ìƒ ì ‘í˜”ìœ¼ë©´ ì£¼ë¨¹ìœ¼ë¡œ ê°„ì£¼
        }

        function dist(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. ì œìŠ¤ì²˜ ì¸ì‹ (ì£¼ë¨¹ vs í´ê¸°)
                isSaturnMode = isFist(landmarks);

                // 2. ì† ìœ„ì¹˜ ê³„ì‚° (í™”ë©´ ì¤‘ì•™ ê¸°ì¤€ ë§¤í•‘)
                const indexFinger = landmarks[9]; // ì†ë°”ë‹¥ ì¤‘ì•™(9) ê¸°ì¤€
                
                const vector = new THREE.Vector3(
                    (1 - indexFinger.x) * 2 - 1,
                    -(indexFinger.y) * 2 + 1,
                    0.5
                );
                vector.unproject(camera);
                const dir = vector.sub(camera.position).normalize();
                const distance = -camera.position.z / dir.z;
                const pos = camera.position.clone().add(dir.multiplyScalar(distance));
                
                handPos.x = pos.x;
                handPos.y = pos.y;
            } else {
                // ì† ì—†ìœ¼ë©´ ì´ˆê¸°í™” ì•ˆí•˜ê³  ê·¸ëƒ¥ ë§ˆì§€ë§‰ ìƒíƒœ ìœ ì§€í•˜ê±°ë‚˜ ë©€ë¦¬ ì¹˜ì›€
                // ì—¬ê¸°ì„  ë°˜ì‘ ì—†ì• ê¸° ìœ„í•´ ë©€ë¦¬ ë³´ëƒ„
                handPos.x = 9999; handPos.y = 9999;
            }
        }

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraUtils.start();

        // 4. ì• ë‹ˆë©”ì´ì…˜
        function animate() {
            requestAnimationFrame(animate);

            const posAttr = particles.geometry.attributes.position;
            const posArr = posAttr.array;

            // ëª¨ë“œë³„ ì„¤ì •
            const moveSpeed = isSaturnMode ? 0.06 : 0.05; 
            const rotationSpeed = isSaturnMode ? 0.02 : 0.001;

            const waveRadius = 15; 
            const waveForce = 3;

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const px = posArr[i3];
                const py = posArr[i3 + 1];
                const pz = posArr[i3 + 2];

                // ëª©í‘œ ìœ„ì¹˜: ì£¼ë¨¹(í† ì„±) vs í´ê¸°(ì›ë˜ìœ„ì¹˜)
                let targetX = isSaturnMode ? saturnPositions[i3] : originalPositions[i3];
                let targetY = isSaturnMode ? saturnPositions[i3 + 1] : originalPositions[i3 + 1];
                let targetZ = isSaturnMode ? saturnPositions[i3 + 2] : originalPositions[i3 + 2];

                // ì´ë™ (Lerp)
                posArr[i3] += (targetX - px) * moveSpeed;
                posArr[i3 + 1] += (targetY - py) * moveSpeed;
                posArr[i3 + 2] += (targetZ - pz) * moveSpeed;

                // [ë¬¼ê²° íš¨ê³¼] ì£¼ë¨¹ ì•ˆ ì¥ì—ˆì„ ë•Œë§Œ(isSaturnMode == false) ì‘ë™
                if (!isSaturnMode) {
                    const dx = px - handPos.x;
                    const dy = py - handPos.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if (dist < waveRadius) {
                        const angle = Math.atan2(dy, dx);
                        const force = (1 - dist / waveRadius) * waveForce;
                        posArr[i3] += Math.cos(angle) * force;
                        posArr[i3 + 1] += Math.sin(angle) * force;
                    }
                }
            }

            posAttr.needsUpdate = true;
            
            // íšŒì „
            particles.rotation.y += rotationSpeed;
            if(isSaturnMode) {
                 particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, 0.5, 0.05);
                 particles.rotation.z = THREE.MathUtils.lerp(particles.rotation.z, 0.3, 0.05);
            } else {
                 particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, 0, 0.05);
                 particles.rotation.z = THREE.MathUtils.lerp(particles.rotation.z, 0, 0.05);
            }

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
            originalPositions[i3 + 2] = positions[i3 + 2];

            // [í† ì„± ëª©í‘œ ìœ„ì¹˜] ê³„ì‚°
            // ì…ìì˜ 25%ëŠ” ì¤‘ì•™ êµ¬ì²´, 75%ëŠ” ê³ ë¦¬ë¡œ ë§Œë“¦
            if (i < particleCount * 0.25) {
                // ì¤‘ì•™ êµ¬ì²´ (ì‘ì€ ë°˜ì§€ë¦„ ë‚´ ëœë¤ ì¢Œí‘œ)
                const radius = Math.random() * 8;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                saturnPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                saturnPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                saturnPositions[i3 + 2] = radius * Math.cos(phi);
            } else {
                // ê³ ë¦¬ (ë„ë„› ëª¨ì–‘)
                const innerRadius = 12;
                const outerRadius = 25;
                const ringRadius = innerRadius + Math.random() * (outerRadius - innerRadius);
                const angle = (i / particleCount) * Math.PI * 2 * 10; // ë§ì´ íšŒì „ì‹œì¼œì„œ ë°€ë„ ë†’ì„
                
                saturnPositions[i3] = Math.cos(angle) * ringRadius;
                saturnPositions[i3 + 1] = (Math.random() -0.5) * 2; // ê³ ë¦¬ ë‘ê»˜ë¥¼ ì–‡ê²Œ
                saturnPositions[i3 + 2] = Math.sin(angle) * ringRadius;
            }
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        // [ê¸ˆìƒ‰ ì¬ì§ˆ]
        const material = new THREE.PointsMaterial({
            color: 0xffcc00, // ë°ì€ ê¸ˆìƒ‰
            size: 0.25,      // ì…ì í¬ê¸° ì‘ê²Œ
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending, // ë¹›ë‚˜ëŠ” íš¨ê³¼ ì¶”ê°€
            sizeAttenuation: true // ë©€ë¦¬ ìˆëŠ”ê±´ ì‘ê²Œ
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // ì† ìœ„ì¹˜ ì´ˆê¸°ê°’
        let handPos = { x: 9999, y: 9999, z: 0 };

        // 3. MediaPipe Hands ì„¤ì • (ì´ì „ê³¼ ë™ì¼)
        const videoElement = document.getElementById('input_video');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                // ê²€ì§€(8)ê³¼ ì—„ì§€(4)ì˜ ì¤‘ê°„ì ì„ ë©”ì¸ ì»¨íŠ¸ë¡¤ í¬ì¸íŠ¸ë¡œ ì¡ìŒ (ì¢€ ë” ì•ˆì •ì )
                const indexFinger = landmarks[8];
                const thumb = landmarks[4];
                const midX = (indexFinger.x + thumb.x) / 2;
                const midY = (indexFinger.y + thumb.y) / 2;

                const vector = new THREE.Vector3(
                    (1 - midX) * 2 - 1,
                    -(midY) * 2 + 1,
                    0.5
                );
                vector.unproject(camera);
                const dir = vector.sub(camera.position).normalize();
                const distance = -camera.position.z / dir.z;
                const pos = camera.position.clone().add(dir.multiplyScalar(distance));
                
                handPos.x = pos.x;
                handPos.y = pos.y;
            } else {
                handPos.x = 9999; handPos.y = 9999;
            }
        }

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraUtils.start();

        // 4. ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ (í•µì‹¬ ë¡œì§ ë³€ê²½)
        function animate() {
            requestAnimationFrame(animate);

            const posAttr = particles.geometry.attributes.position;
            const posArr = posAttr.array;

            // ì†ì´ í™”ë©´ ì¤‘ì•™(0,0)ì—ì„œ ì–¼ë§ˆë‚˜ ë¨¼ì§€ ê³„ì‚°
            // ì†ì´ ê°ì§€ë˜ì§€ ì•Šì•˜ì„ ë•Œ(9999)ëŠ” ê±°ë¦¬ê°€ ë§¤ìš° ì»¤ì§
            const distToCenter = Math.sqrt(handPos.x * handPos.x + handPos.y * handPos.y);
            
            // ì¤‘ì•™ì—ì„œ ë°˜ì§€ë¦„ 15 ì´ë‚´ë¡œ ë“¤ì–´ì˜¤ë©´ í† ì„± ëª¨ë“œ ë°œë™
            // ì†ì´ ê°ì§€ ì•ˆë ë•ŒëŠ” ë°œë™ ì•ˆí•˜ê²Œ ì²´í¬ (distToCenter < 2000)
            isSaturnMode = (distToCenter < 15) && (distToCenter < 2000);

            // ëª¨ë“œì— ë”°ë¥¸ íŒŒë¼ë¯¸í„° ì„¤ì •
            const moveSpeed = isSaturnMode ? 0.04 : 0.05; // í† ì„±ìœ¼ë¡œ ëª¨ì¼ ë•Œ ì†ë„
            const rotationSpeed = isSaturnMode ? 0.01 : 0.001; // í† ì„±ì¼ ë•Œ ë” ë¹¨ë¦¬ ë”
            
            // ì† ë¬¼ê²° íš¨ê³¼ íŒŒë¼ë¯¸í„°
            const waveRadius = 10; 
            const waveForce = 3;

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const px = posArr[i3];
                const py = posArr[i3 + 1];
                const pz = posArr[i3 + 2];

                // 1. ëª©í‘œ ìœ„ì¹˜ ê²°ì • (í† ì„± ëª¨ë“œ vs ì¼ë°˜ ëª¨ë“œ)
                let targetX = isSaturnMode ? saturnPositions[i3] : originalPositions[i3];
                let targetY = isSaturnMode ? saturnPositions[i3 + 1] : originalPositions[i3 + 1];
                let targetZ = isSaturnMode ? saturnPositions[i3 + 2] : originalPositions[i3 + 2];

                // 2. ëª©í‘œ ìœ„ì¹˜ë¡œ ë¶€ë“œëŸ½ê²Œ ì´ë™ (Lerp)
                posArr[i3] += (targetX - px) * moveSpeed;
                posArr[i3 + 1] += (targetY - py) * moveSpeed;
                posArr[i3 + 2] += (targetZ - pz) * moveSpeed;

                // 3. ì¼ë°˜ ëª¨ë“œì¼ ë•Œë§Œ ì† ë¬¼ê²° íš¨ê³¼ ì ìš©
                if (!isSaturnMode) {
                    const dx = px - handPos.x;
                    const dy = py - handPos.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < waveRadius && dist > 0) {
                        const angle = Math.atan2(dy, dx);
                        const force = (1 - dist / waveRadius) * waveForce;
                        posArr[i3] += Math.cos(angle) * force;
                        posArr[i3 + 1] += Math.sin(angle) * force;
                    }
                }
            }

            posAttr.needsUpdate = true;
            
            // ì „ì²´ íšŒì „ ì ìš©
            particles.rotation.y += rotationSpeed;
            if(isSaturnMode) {
                 // í† ì„± ëª¨ë“œì¼ ë•Œ ì•½ê°„ ê¸°ìš¸ì—¬ì„œ ë©‹ë‚´ê¸°
                 particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, 0.4, 0.05);
                 particles.rotation.z = THREE.MathUtils.lerp(particles.rotation.z, 0.2, 0.05);
            } else {
                 // ì¼ë°˜ ëª¨ë“œì¼ ë•Œ íšŒì „ ì›ìƒë³µêµ¬
                 particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, 0, 0.05);
                 particles.rotation.z = THREE.MathUtils.lerp(particles.rotation.z, 0, 0.05);
            }


            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
