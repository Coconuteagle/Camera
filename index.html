<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Hand Gesture Universe</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; }
        video { display: none; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #ffd700;
            font-family: 'Pretendard', sans-serif;
            pointer-events: none;
            z-index: 10;
            text-shadow: 0 0 5px black;
            font-size: 1.1rem;
            line-height: 1.5;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <div id="info">
        ğŸ– ì†ë°”ë‹¥: ì•(í›„í‡´) / ë’¤(ëŒì§„)<br>
        âœŠ ì£¼ë¨¹: ìƒí•˜ì¢Œìš°(í† ì„± íšŒì „ ê´€ì°°)
    </div>
    <video id="input_video"></video>
    
    <script>
        // ìƒíƒœ ë³€ìˆ˜ë“¤
        let isSaturnMode = false;
        let handNormalized = { x: 0, y: 0, z: 0 }; // ì†ì˜ í™”ë©´ìƒ ìƒëŒ€ ì¢Œí‘œ (-1 ~ 1) ë° ê±°ë¦¬(í¬ê¸°)

        // 1. Three.js ì”¬ ì„¤ì •
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.002); // ì•ˆê°œ ë†ë„ ì¡°ì ˆ
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        camera.position.z = 100;

        // 2. ì…ì ìƒì„±
        const particleCount = 12000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const originalPositions = new Float32Array(particleCount * 3); // í´ì¡Œì„ ë•Œ(ìš°ì£¼) ìœ„ì¹˜
        const saturnPositions = new Float32Array(particleCount * 3);   // í† ì„± ìœ„ì¹˜

        // ì´ˆê¸°í™”
        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;

            // [ìš°ì£¼ ëª¨ë“œ] ê¹Šì´ê°ì„ ìœ„í•´ Zì¶•ì„ ì•„ì£¼ ê¸¸ê²Œ ë°°ì¹˜
            const spreadXY = 200; 
            const spreadZ = 400; 

            positions[i3] = (Math.random() - 0.5) * spreadXY;
            positions[i3 + 1] = (Math.random() - 0.5) * spreadXY;
            positions[i3 + 2] = (Math.random() - 0.5) * spreadZ; // -200 ~ 200
            
            originalPositions[i3] = positions[i3];
            originalPositions[i3 + 1] = positions[i3 + 1];
            originalPositions[i3 + 2] = positions[i3 + 2];

            // [í† ì„± ëª¨ë“œ] ì¢Œí‘œ ê³„ì‚°
            if (i < particleCount * 0.3) { // 30%ëŠ” í–‰ì„± ë³¸ì²´
                const radius = Math.random() * 15; // í¬ê¸° ì¢€ í‚¤ì›€
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                saturnPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                saturnPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                saturnPositions[i3 + 2] = radius * Math.cos(phi);
            } else { // 70%ëŠ” ê³ ë¦¬
                const innerRadius = 20;
                const outerRadius = 45;
                const ringRadius = innerRadius + Math.random() * (outerRadius - innerRadius);
                const angle = (i / particleCount) * Math.PI * 2 * 15;
                
                saturnPositions[i3] = Math.cos(angle) * ringRadius;
                saturnPositions[i3 + 1] = (Math.random() - 0.5) * 2; // ê³ ë¦¬ ë‘ê»˜
                saturnPositions[i3 + 2] = Math.sin(angle) * ringRadius;
            }
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const material = new THREE.PointsMaterial({
            color: 0xffcc00, 
            size: 0.5,      
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // 3. MediaPipe ì„¤ì •
        const videoElement = document.getElementById('input_video');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // ê±°ë¦¬ ê³„ì‚° í—¬í¼
        function dist(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        function isFist(landmarks) {
            // ì†ê°€ë½ ì ‘í˜ ì—¬ë¶€ íŒë‹¨ (ê°„ì†Œí™”)
            const wrist = landmarks[0];
            const tips = [8, 12, 16, 20]; // ê²€ì§€~ìƒˆë¼ ë
            const pips = [6, 10, 14, 18]; // ê²€ì§€~ìƒˆë¼ ì¤‘ê°„ê´€ì ˆ
            
            let folded = 0;
            for(let i=0; i<4; i++) {
                if (dist(wrist, landmarks[tips[i]]) < dist(wrist, landmarks[pips[i]]) * 1.3) {
                    folded++;
                }
            }
            return folded >= 3;
        }

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. ì œìŠ¤ì²˜ ëª¨ë“œ ë³€ê²½
                isSaturnMode = isFist(landmarks);

                // 2. ì† ì •ë³´ ì¶”ì¶œ
                // ì† ì¤‘ì‹¬ (ëŒ€ëµ 9ë²ˆ ê´€ì ˆ)
                const palmCenter = landmarks[9];
                
                // í™”ë©´ ì¢Œí‘œê³„ (-1 ~ 1) ë¡œ ë³€í™˜
                // x: ì™¼ìª½ì´ -1, ì˜¤ë¥¸ìª½ì´ 1 (ì¢Œìš°ë°˜ì „ ì²˜ë¦¬)
                // y: ìœ„ê°€ 1, ì•„ë˜ê°€ -1
                handNormalized.x = (1 - palmCenter.x) * 2 - 1; 
                handNormalized.y = -(palmCenter.y) * 2 + 1;

                // 3. ì† ê¹Šì´(ê±°ë¦¬) ì¶”ì •
                // ì†ëª©(0)ê³¼ ì¤‘ì§€ë¿Œë¦¬(9) ì‚¬ì´ì˜ ê±°ë¦¬ëŠ” ì† í¬ê¸°ì— ë¹„ë¡€í•¨ -> ì¹´ë©”ë¼ì™€ì˜ ê±°ë¦¬ ì—­ìˆ˜
                // ê°€ê¹Œìš°ë©´(í¬ë©´) ê°’ì´ ì»¤ì§ (ì•½ 0.1 ~ 0.3)
                const handSize = dist(landmarks[0], landmarks[9]);
                handNormalized.z = handSize;

            } else {
                // ì† ì—†ì„ ë•Œ ì´ˆê¸°í™” (ì„ íƒì‚¬í•­)
                handNormalized.z = 0; // ì›€ì§ì„ ë©ˆì¶¤
            }
        }

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraUtils.start();

        // 4. ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
        function animate() {
            requestAnimationFrame(animate);

            const posAttr = particles.geometry.attributes.position;
            const posArr = posAttr.array;

            // --- [ëª¨ë“œ 1: ì†ë°”ë‹¥ í´ì§ (ìš°ì£¼ ë¹„í–‰)] ---
            if (!isSaturnMode) {
                // ì† í¬ê¸° ê¸°ì¤€ê°’ (ì´ê±°ë³´ë‹¤ í¬ë©´ ì „ì§„, ì‘ìœ¼ë©´ í›„í‡´)
                const baseSize = 0.15; 
                // ì†ë„ ê³„ìˆ˜
                const speedFactor = 200; 

                // ì†ì´ ê°ì§€ë  ë•Œë§Œ ì´ë™
                let moveSpeed = 0;
                if (handNormalized.z > 0) {
                    // ì†ì´ í¼(ê°€ê¹ë‹¤) -> handNormalized.z > baseSize -> ì–‘ìˆ˜ -> ë³„ë“¤ì´ ë’¤ë¡œê°(Zê°ì†Œ) : í›„í‡´íš¨ê³¼
                    // ì†ì´ ì‘ìŒ(ë©€ë‹¤) -> handNormalized.z < baseSize -> ìŒìˆ˜ -> ë³„ë“¤ì´ ì•ìœ¼ë¡œì˜´(Zì¦ê°€) : ëŒì§„íš¨ê³¼
                    // ìš”ì²­: "ì•ìœ¼ë¡œ ê°€ë©´(ì†í¼) ë³„ë“¤ì´ í›„í‡´", "ë’¤ë¡œ ë¹¼ë©´(ì†ì‘ìŒ) ëŒì§„"
                    
                    // ì†ì´ ì»¤ì§(0.3) -> 0.3 - 0.15 = +0.15. 
                    // ë³„ì„ ì € ë©€ë¦¬ ë³´ë‚´ë ¤ë©´ Zê°’ì„ ì¤„ì—¬ì•¼ í•¨(Minus).
                    moveSpeed = -(handNormalized.z - baseSize) * speedFactor;
                }

                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;

                    // 1) í† ì„± í˜•íƒœì—ì„œ ì›ë˜ ìš°ì£¼ í˜•íƒœë¡œ ë³µê·€ (Lerp)
                    // í˜„ì¬ ìœ„ì¹˜ë¥¼ target(original) ìª½ìœ¼ë¡œ ì²œì²œíˆ ì´ë™
                    posArr[i3]   += (originalPositions[i3] - posArr[i3]) * 0.05;
                    posArr[i3+1] += (originalPositions[i3+1] - posArr[i3+1]) * 0.05;
                    
                    // Zì¶•ì€ Warp íš¨ê³¼ë¥¼ ìœ„í•´ ê³„ì† ì´ë™ì‹œí‚´
                    // ë‹¤ë§Œ í† ì„± ëª¨ì–‘ì´ì—ˆë˜ Zê°’ë„ ì„œì„œíˆ ì›ë˜ëŒ€ë¡œ í´ì£¼ë©´ì„œ ì´ë™
                    let targetZ = originalPositions[i3+2];
                    
                    // í˜„ì¬ Z ìœ„ì¹˜ì— ì†ë„ ì ìš©
                    posArr[i3+2] += moveSpeed;

                    // 2) ë¬´í•œ ìŠ¤í¬ë¡¤ (Warp Loop)
                    const boundary = 200;
                    if (posArr[i3+2] < -boundary) posArr[i3+2] += boundary * 2;
                    if (posArr[i3+2] > boundary) posArr[i3+2] -= boundary * 2;
                    
                    // X, Y ìœ„ì¹˜ëŠ” ì›ë˜ ìë¦¬ë¡œ ëŒì•„ê°€ë ¤ëŠ” í˜ê³¼ ë¬¼ê²° íš¨ê³¼ ì„ê¸°
                    // (ë‹¨ìˆœí™”ë¥¼ ìœ„í•´ ì—¬ê¸°ì„  ë³µê·€ë§Œ ì²˜ë¦¬í•˜ê³  Zì´ë™ì— ì§‘ì¤‘)
                }
                
                // ì†ë°”ë‹¥ì¼ ë• ì „ì²´ íšŒì „ 0ìœ¼ë¡œ ë³µêµ¬
                particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, 0, 0.1);
                particles.rotation.y = THREE.MathUtils.lerp(particles.rotation.y, 0, 0.1);
            } 
            
            // --- [ëª¨ë“œ 2: ì£¼ë¨¹ ì¥  (í† ì„± ê´€ì°°)] ---
            else {
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    // í† ì„± ëª¨ì–‘ìœ¼ë¡œ ì§‘ê²°
                    posArr[i3]   += (saturnPositions[i3] - posArr[i3]) * 0.08;
                    posArr[i3+1] += (saturnPositions[i3+1] - posArr[i3+1]) * 0.08;
                    posArr[i3+2] += (saturnPositions[i3+2] - posArr[i3+2]) * 0.08;
                }

                // **í•µì‹¬: ì…ì ì „ì²´ ë©ì–´ë¦¬ë¥¼ ì† ì›€ì§ì„ì— ë”°ë¼ íšŒì „**
                // handNormalized.y (ìœ„ì•„ë˜) -> Xì¶• íšŒì „ (ë„ë•ë„ë•)
                // handNormalized.x (ì¢Œìš°) -> Yì¶• íšŒì „ (ë„ë¦¬ë„ë¦¬)
                const targetRotX = -handNormalized.y * 2; // ê°ë„ ì¡°ì ˆ
                const targetRotY = handNormalized.x * 2;

                particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, targetRotX, 0.1);
                particles.rotation.y = THREE.MathUtils.lerp(particles.rotation.y, targetRotY, 0.1);
            }

            posAttr.needsUpdate = true;
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>

            // í† ì„± ëª©í‘œ ìœ„ì¹˜ ê³„ì‚°
            if (i < particleCount * 0.25) { // ì¤‘ì•™ êµ¬ì²´
                const radius = Math.random() * 8;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                saturnPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                saturnPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                saturnPositions[i3 + 2] = radius * Math.cos(phi);
            } else { // ê³ ë¦¬
                const innerRadius = 12;
                const outerRadius = 25;
                const ringRadius = innerRadius + Math.random() * (outerRadius - innerRadius);
                const angle = (i / particleCount) * Math.PI * 2 * 10;
                
                saturnPositions[i3] = Math.cos(angle) * ringRadius;
                saturnPositions[i3 + 1] = (Math.random() -0.5) * 1.5; 
                saturnPositions[i3 + 2] = Math.sin(angle) * ringRadius;
            }
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const material = new THREE.PointsMaterial({
            color: 0xffcc00, 
            size: 0.3,      
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // ì† ì¢Œí‘œ
        let handPos = { x: 9999, y: 9999 };

        // 3. MediaPipe Hands
        const videoElement = document.getElementById('input_video');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // ì£¼ë¨¹ ì¸ì‹ í•¨ìˆ˜
        function isFist(landmarks) {
            // ì ‘íŒ ì†ê°€ë½ ê°œìˆ˜ ì„¸ê¸° (ì—„ì§€ ì œì™¸ ê²€ì§€~ìƒˆë¼)
            let foldedCount = 0;
            // 8:ê²€ì§€ë, 6:ê²€ì§€ê´€ì ˆ ... 
            if (landmarks[8].y > landmarks[6].y) foldedCount++;  // í™”ë©´ìƒ ì•„ë˜ìª½ì´ yê°’ì´ í¼ (ë³´í†µ ì†ê°€ë½ ë‚´ë¦¬ë©´ yì¦ê°€)
            if (landmarks[12].y > landmarks[10].y) foldedCount++;
            if (landmarks[16].y > landmarks[14].y) foldedCount++;
            if (landmarks[20].y > landmarks[18].y) foldedCount++;
            
            // ì†ì´ ë’¤ì§‘í˜€ìˆì„ ìˆ˜ë„ ìˆìœ¼ë‹ˆ, ì†ëª©(0)ê³¼ ì†ê°€ë½ ë ê±°ë¦¬ë¡œ íŒë‹¨í•˜ëŠ” ê²Œ ë” ì •í™•í•¨
            const wrist = landmarks[0];
            const tips = [8, 12, 16, 20];
            const pips = [6, 10, 14, 18]; // ì¤‘ê°„ ê´€ì ˆ
            
            let closeCount = 0;
            for(let i=0; i<4; i++) {
                // ì†ëª©-ì†ë ê±°ë¦¬ vs ì†ëª©-ì¤‘ê°„ê´€ì ˆ ê±°ë¦¬ ë¹„êµ
                const dTip = dist(wrist, landmarks[tips[i]]);
                const dPip = dist(wrist, landmarks[pips[i]]);
                // ì†ëì´ ê´€ì ˆë³´ë‹¤ ì†ëª©ì— ê°€ê¹Œìš°ë©´ ì ‘íŒ ê²ƒ
                if (dTip < dPip * 1.2) closeCount++; 
            }
            
            return closeCount >= 3; // 3ê°œ ì´ìƒ ì ‘í˜”ìœ¼ë©´ ì£¼ë¨¹ìœ¼ë¡œ ê°„ì£¼
        }

        function dist(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. ì œìŠ¤ì²˜ ì¸ì‹ (ì£¼ë¨¹ vs í´ê¸°)
                isSaturnMode = isFist(landmarks);

                // 2. ì† ìœ„ì¹˜ ê³„ì‚° (í™”ë©´ ì¤‘ì•™ ê¸°ì¤€ ë§¤í•‘)
                const indexFinger = landmarks[9]; // ì†ë°”ë‹¥ ì¤‘ì•™(9) ê¸°ì¤€
                
                const vector = new THREE.Vector3(
                    (1 - indexFinger.x) * 2 - 1,
                    -(indexFinger.y) * 2 + 1,
                    0.5
                );
                vector.unproject(camera);
                const dir = vector.sub(camera.position).normalize();
                const distance = -camera.position.z / dir.z;
                const pos = camera.position.clone().add(dir.multiplyScalar(distance));
                
                handPos.x = pos.x;
                handPos.y = pos.y;
            } else {
                // ì† ì—†ìœ¼ë©´ ì´ˆê¸°í™” ì•ˆí•˜ê³  ê·¸ëƒ¥ ë§ˆì§€ë§‰ ìƒíƒœ ìœ ì§€í•˜ê±°ë‚˜ ë©€ë¦¬ ì¹˜ì›€
                // ì—¬ê¸°ì„  ë°˜ì‘ ì—†ì• ê¸° ìœ„í•´ ë©€ë¦¬ ë³´ëƒ„
                handPos.x = 9999; handPos.y = 9999;
            }
        }

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraUtils.start();

        // 4. ì• ë‹ˆë©”ì´ì…˜
        function animate() {
            requestAnimationFrame(animate);

            const posAttr = particles.geometry.attributes.position;
            const posArr = posAttr.array;

            // ëª¨ë“œë³„ ì„¤ì •
            const moveSpeed = isSaturnMode ? 0.06 : 0.05; 
            const rotationSpeed = isSaturnMode ? 0.02 : 0.001;

            const waveRadius = 15; 
            const waveForce = 3;

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const px = posArr[i3];
                const py = posArr[i3 + 1];
                const pz = posArr[i3 + 2];

                // ëª©í‘œ ìœ„ì¹˜: ì£¼ë¨¹(í† ì„±) vs í´ê¸°(ì›ë˜ìœ„ì¹˜)
                let targetX = isSaturnMode ? saturnPositions[i3] : originalPositions[i3];
                let targetY = isSaturnMode ? saturnPositions[i3 + 1] : originalPositions[i3 + 1];
                let targetZ = isSaturnMode ? saturnPositions[i3 + 2] : originalPositions[i3 + 2];

                // ì´ë™ (Lerp)
                posArr[i3] += (targetX - px) * moveSpeed;
                posArr[i3 + 1] += (targetY - py) * moveSpeed;
                posArr[i3 + 2] += (targetZ - pz) * moveSpeed;

                // [ë¬¼ê²° íš¨ê³¼] ì£¼ë¨¹ ì•ˆ ì¥ì—ˆì„ ë•Œë§Œ(isSaturnMode == false) ì‘ë™
                if (!isSaturnMode) {
                    const dx = px - handPos.x;
                    const dy = py - handPos.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if (dist < waveRadius) {
                        const angle = Math.atan2(dy, dx);
                        const force = (1 - dist / waveRadius) * waveForce;
                        posArr[i3] += Math.cos(angle) * force;
                        posArr[i3 + 1] += Math.sin(angle) * force;
                    }
                }
            }

            posAttr.needsUpdate = true;
            
            // íšŒì „
            particles.rotation.y += rotationSpeed;
            if(isSaturnMode) {
                 particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, 0.5, 0.05);
                 particles.rotation.z = THREE.MathUtils.lerp(particles.rotation.z, 0.3, 0.05);
            } else {
                 particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, 0, 0.05);
                 particles.rotation.z = THREE.MathUtils.lerp(particles.rotation.z, 0, 0.05);
            }

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
            originalPositions[i3 + 2] = positions[i3 + 2];

            // [í† ì„± ëª©í‘œ ìœ„ì¹˜] ê³„ì‚°
            // ì…ìì˜ 25%ëŠ” ì¤‘ì•™ êµ¬ì²´, 75%ëŠ” ê³ ë¦¬ë¡œ ë§Œë“¦
            if (i < particleCount * 0.25) {
                // ì¤‘ì•™ êµ¬ì²´ (ì‘ì€ ë°˜ì§€ë¦„ ë‚´ ëœë¤ ì¢Œí‘œ)
                const radius = Math.random() * 8;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                saturnPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                saturnPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                saturnPositions[i3 + 2] = radius * Math.cos(phi);
            } else {
                // ê³ ë¦¬ (ë„ë„› ëª¨ì–‘)
                const innerRadius = 12;
                const outerRadius = 25;
                const ringRadius = innerRadius + Math.random() * (outerRadius - innerRadius);
                const angle = (i / particleCount) * Math.PI * 2 * 10; // ë§ì´ íšŒì „ì‹œì¼œì„œ ë°€ë„ ë†’ì„
                
                saturnPositions[i3] = Math.cos(angle) * ringRadius;
                saturnPositions[i3 + 1] = (Math.random() -0.5) * 2; // ê³ ë¦¬ ë‘ê»˜ë¥¼ ì–‡ê²Œ
                saturnPositions[i3 + 2] = Math.sin(angle) * ringRadius;
            }
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        // [ê¸ˆìƒ‰ ì¬ì§ˆ]
        const material = new THREE.PointsMaterial({
            color: 0xffcc00, // ë°ì€ ê¸ˆìƒ‰
            size: 0.25,      // ì…ì í¬ê¸° ì‘ê²Œ
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending, // ë¹›ë‚˜ëŠ” íš¨ê³¼ ì¶”ê°€
            sizeAttenuation: true // ë©€ë¦¬ ìˆëŠ”ê±´ ì‘ê²Œ
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // ì† ìœ„ì¹˜ ì´ˆê¸°ê°’
        let handPos = { x: 9999, y: 9999, z: 0 };

        // 3. MediaPipe Hands ì„¤ì • (ì´ì „ê³¼ ë™ì¼)
        const videoElement = document.getElementById('input_video');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                // ê²€ì§€(8)ê³¼ ì—„ì§€(4)ì˜ ì¤‘ê°„ì ì„ ë©”ì¸ ì»¨íŠ¸ë¡¤ í¬ì¸íŠ¸ë¡œ ì¡ìŒ (ì¢€ ë” ì•ˆì •ì )
                const indexFinger = landmarks[8];
                const thumb = landmarks[4];
                const midX = (indexFinger.x + thumb.x) / 2;
                const midY = (indexFinger.y + thumb.y) / 2;

                const vector = new THREE.Vector3(
                    (1 - midX) * 2 - 1,
                    -(midY) * 2 + 1,
                    0.5
                );
                vector.unproject(camera);
                const dir = vector.sub(camera.position).normalize();
                const distance = -camera.position.z / dir.z;
                const pos = camera.position.clone().add(dir.multiplyScalar(distance));
                
                handPos.x = pos.x;
                handPos.y = pos.y;
            } else {
                handPos.x = 9999; handPos.y = 9999;
            }
        }

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraUtils.start();

        // 4. ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ (í•µì‹¬ ë¡œì§ ë³€ê²½)
        function animate() {
            requestAnimationFrame(animate);

            const posAttr = particles.geometry.attributes.position;
            const posArr = posAttr.array;

            // ì†ì´ í™”ë©´ ì¤‘ì•™(0,0)ì—ì„œ ì–¼ë§ˆë‚˜ ë¨¼ì§€ ê³„ì‚°
            // ì†ì´ ê°ì§€ë˜ì§€ ì•Šì•˜ì„ ë•Œ(9999)ëŠ” ê±°ë¦¬ê°€ ë§¤ìš° ì»¤ì§
            const distToCenter = Math.sqrt(handPos.x * handPos.x + handPos.y * handPos.y);
            
            // ì¤‘ì•™ì—ì„œ ë°˜ì§€ë¦„ 15 ì´ë‚´ë¡œ ë“¤ì–´ì˜¤ë©´ í† ì„± ëª¨ë“œ ë°œë™
            // ì†ì´ ê°ì§€ ì•ˆë ë•ŒëŠ” ë°œë™ ì•ˆí•˜ê²Œ ì²´í¬ (distToCenter < 2000)
            isSaturnMode = (distToCenter < 15) && (distToCenter < 2000);

            // ëª¨ë“œì— ë”°ë¥¸ íŒŒë¼ë¯¸í„° ì„¤ì •
            const moveSpeed = isSaturnMode ? 0.04 : 0.05; // í† ì„±ìœ¼ë¡œ ëª¨ì¼ ë•Œ ì†ë„
            const rotationSpeed = isSaturnMode ? 0.01 : 0.001; // í† ì„±ì¼ ë•Œ ë” ë¹¨ë¦¬ ë”
            
            // ì† ë¬¼ê²° íš¨ê³¼ íŒŒë¼ë¯¸í„°
            const waveRadius = 10; 
            const waveForce = 3;

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const px = posArr[i3];
                const py = posArr[i3 + 1];
                const pz = posArr[i3 + 2];

                // 1. ëª©í‘œ ìœ„ì¹˜ ê²°ì • (í† ì„± ëª¨ë“œ vs ì¼ë°˜ ëª¨ë“œ)
                let targetX = isSaturnMode ? saturnPositions[i3] : originalPositions[i3];
                let targetY = isSaturnMode ? saturnPositions[i3 + 1] : originalPositions[i3 + 1];
                let targetZ = isSaturnMode ? saturnPositions[i3 + 2] : originalPositions[i3 + 2];

                // 2. ëª©í‘œ ìœ„ì¹˜ë¡œ ë¶€ë“œëŸ½ê²Œ ì´ë™ (Lerp)
                posArr[i3] += (targetX - px) * moveSpeed;
                posArr[i3 + 1] += (targetY - py) * moveSpeed;
                posArr[i3 + 2] += (targetZ - pz) * moveSpeed;

                // 3. ì¼ë°˜ ëª¨ë“œì¼ ë•Œë§Œ ì† ë¬¼ê²° íš¨ê³¼ ì ìš©
                if (!isSaturnMode) {
                    const dx = px - handPos.x;
                    const dy = py - handPos.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < waveRadius && dist > 0) {
                        const angle = Math.atan2(dy, dx);
                        const force = (1 - dist / waveRadius) * waveForce;
                        posArr[i3] += Math.cos(angle) * force;
                        posArr[i3 + 1] += Math.sin(angle) * force;
                    }
                }
            }

            posAttr.needsUpdate = true;
            
            // ì „ì²´ íšŒì „ ì ìš©
            particles.rotation.y += rotationSpeed;
            if(isSaturnMode) {
                 // í† ì„± ëª¨ë“œì¼ ë•Œ ì•½ê°„ ê¸°ìš¸ì—¬ì„œ ë©‹ë‚´ê¸°
                 particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, 0.4, 0.05);
                 particles.rotation.z = THREE.MathUtils.lerp(particles.rotation.z, 0.2, 0.05);
            } else {
                 // ì¼ë°˜ ëª¨ë“œì¼ ë•Œ íšŒì „ ì›ìƒë³µêµ¬
                 particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, 0, 0.05);
                 particles.rotation.z = THREE.MathUtils.lerp(particles.rotation.z, 0, 0.05);
            }


            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
